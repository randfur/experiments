# 2025-10-11
- Maybe start implementing algorithm.

# 2025-10-09
- Recreated drawings in notepad in JSPaint.
  - arc-slice.png

# 2025-10-04
- Removed hexagon plane test, back to simple cube.
- Recollecting algorithm on pen and paper:
  - For each arc:
    - Create arc model.
    - Create temp arc face.
    - For each face in model:
      - Create temp side face.
      - For each edge in face:
        - Test if start point is inside arc, add to temp side face.
        - If projected start and end points straddle the arc start line:
          - Get intersection point.
          - Add point to temp side face.
          - Add point to temp arc face.
      - If edge start points were both inside and outside the arc:
        - Get intersection point of slice direction with face.
        - If point is inside face:
          - Add point to temp arc face.
      - Add temp side face to arc model.
    - Sort temp arc face points by angle.
    - Add temp arc face to arc model.

# 2025-09-29
- The algorithm is a bit complicated and would be hard to remember.
  - Maybe creating an animation of it would be helpful.

# 2025-08-24
- Forked this off as slanted-hexagons to preserve the collision detection test.

# 2025-08-23
- To do the SALT 2D collision detection all the face vertices will need to have the same winding.
  - The direction of the normal and subsequent plane basis vectors also affect how to do the SALT check.
  - Will need to do some testing.
- Created test hexagon face.
  - Extracted normal.
  - Created plane basis from normal.
  - Updated Vec3.setNonParallel() to produce a plane basis that's the same handedness as the co-ordinate space (left handed) when the face runs counter clockwise in the XY plane and has the basis X->Y also run counter clockwise.
    - This works fine for a front face but what happens for a back face where points run clockwise instead?
      - The normal should be in the opposite direction and produce opposite results.
      - Needs testing.
      - Reversed the face points, observed that the normal reversed and the plane basis is still left handed and still follows the direction of the points (clockwise).
    - Should update the angle sort approximation function below to increase counter clockwise rather than clockwise.
      - Done:
        abs(pos.x) > abs(pos.y)
        ? (float(pos.x < 0.) * 4.) + 1. + (pos.y / pos.x)
        : (float(pos.y < 0.) * 4.) + 3. - (pos.x / pos.y);
  - Implemented projected collision detection.
    - It works, yay.

# 2025-08-21
- Removed testing projection dots.
- Rewrote main to be a testing cake slice.
- Will add model orientation support after this works to test cornery cases.
- Added plane basis concept; normal plus arbitrary plane basis vectors.
- Added Vec2 and place projection down into Vec2 land using the arbitrary plan basis vectors.
  - Seems like I could just use Vec3 with z = 0.
  - Might do that instead actually, save a lot of duplicate code.
  - Went with Vec3 and upstreaming it all including a new PlaneBasis class into the ga library.
- Need to detect if middle line intersects a face.
  - Need to get the plane basis of a face and do the collision detection in 2D.

# 2025-08-18
- Added another inplacePlaneProjection() on top of the first one for double plane projection.
  - Just curious how it would look.
  - Occasional squashing into a straight line otherwise not much different.

# 2025-08-10
- Worked on sorting 2D vectors by angle.
  - Came up with a different scheme to approximate an angle to sort by:
    - https://www.shadertoy.com/view/tXVXRK
    - abs(x) > abs(y)
      ? ((x < 0) * 4) + 1 - y / x
      : ((y > 0) * 4) + 3 + x / y;
- Thoughts about what to ultimately make with this cake slicing:
  - A very large box that's too close to the camera for its edges to be seen.
  - A snake that glides through space and slices the box whenever it encounters a face.
    - Starts behind the camera and moves forward to hit the front face of the big box.
    - Has a cooldown of a few seconds between slices so it doesn't spam slices on the pieces it just sliced.
  - The colour the snake slices with changes over time, maybe some bias based on 3D position.
  - Slice pieces slowly drift away from the impact point.
    - Would be neat to have rotation involved too.
  - A cap on the max number of pieces, excess small pieces fade away.
  - Pieces that float off screen are culled also.
  - When there are no pieces wait for the snake to go off screen and then restart the whole thing.
- Slicing needs at least 3 vectors and the max angle between any adjacent pair must be < tau/2.
  - How to detect angle of over tau/2?
  - Take dot product with tau/4 rotation of first vector.
  - Result must be > 0.
- Renamed experiment from model-faces to cake-slices.
- Need to get basis vectors for a plane normal and put 3D points on the plane in terms of those basis vectors.
- Tested out the new Vec3.setPlaneProjection() method.
  - Looks like it works.

# 2025-08-01
- Decided to do n way splits.
  - Like cutting cake slices.
  - Plane splits that all join at a line.
  - Considering constraint that the largest angle between two planes can't be more than 180 degrees.
    - Will need to figure out how to test that.
    - Maybe provide helper to add a mid plane in such cases.
- Whiteboarding.
  - https://photos.google.com/photo/AF1QipMlhPhH3ZuOBuZnw3SmxLxZPqmdrXEGGSlCdQ2d
    - How to sort points in a circle without using atan2().
    - Four categories:
      - 1: Pointing straight up.
      - 2: Pointing to the right.
      - 3: Pointing straight down.
      - 4: Pointing to the left.
    - Get numeric category of points a and b and just subtract.
    - If both are the same and in either category 2 or 4 then compare gradient slopes.
  - https://photos.google.com/photo/AF1QipOCbo4GrRrH2JrCUjyeXDxIIj7vQAQFYO-AqOfm
    - Slicing planes A, B, C.
    - Face with vertices 1, 2, 3, 4.
    - Iterate through the edges 1->2, 2->3, 3->4, 4->1.
    - Add vertices and intersections with slicing planes into respective buckets.
    - Each plane has two vertex buckets:
      - On: Vertices that lie on the plane.
      - In: Vertices that lie within the angle between the plane and the next one e.g. A->B.
    - The On verticies are collected over the course of the entire model slicing and are sorted by angle to form a new convex face shared by adjacent split models.
    - The In vertices form the face for the respective split model inside that slice segment.
- How to determine whether a point lies within the A->B segment?
  - Use SALT.
  - This would work best in 2D space.
  - All these vectors and vertices are 3D.
  - Should maybe add Vec2 to the ga repo and have some Vec3 methods that return Vec2s that represent position on a 3D plane.
    - Can probably just use arbitrary basis vectors.
    - (x, y, z) -> (z, x, -y) is a good way to generate a non-parallel vector to the normal that can be projected to be orthogonal.

# 2025-07-28
- Implementing model with edges.
- Going to define a map of directional edges to reduce the overpainting that building/ had with drawing each face's edge, all edges being drawn twice.
- Compute the faces from the edges as needed.
- Doesn't make good use of hex-lines' ability to draw continuous lines, would have null points inbetween each edge.
- Not as bad as redundant draws but not as optimal.
- How to fill in a cube's edges with as few breaks as possible?
- Hard to find fewer than 4, each vertex needs to be visited 3 times, makes it hard to visit them all cleanly.
- Unsure if this optimisation is worth it.
  - Defining each face allows for the faces to have their own size and colour.
- Going to stick with a face list instead of edge map.
- Considering how to make impact fractures rather than a slice.
  - This would split the model up into more than two pieces and be able to keep the resulting pieces convex.
  - Ideally has a degree of randomness in the structure of the fracture and multiple directions that turn rather than going on forever like the plane split.
  - This involves creating new vertices that are within the face rather than on its edges.
    - Testing for whether a point is inside a face would probably need the SALT method.
    - Separating axis line theorum.
    - This assumes every face is convex.
      - If the fractured pieces are convex then so are all its faces.
    - For each edge check that the point is not on the outer side of it.
      - Would need to inspect two connected non-parallel edges to know which way "out" is.
- How to structure the 3 dimensional form of the fracture?
  - Maybe an initial number of spikes followed by splitting trapezoids.
  - Maybe a jagged cone shape.
    - Inner ring, random number of vertices.
    - At each ring edge have a split coming back towards the impact to have small pieces.
    - Then splits going into the model for the large fractures that span the entire thing.
    - Maybe a single line going inwards before creating the ring.
      - Probably can't be a jagged line or it might create concave pieces.
  - In order to remain convex every fracture edge going in must split into two fracture edges.
    - If the edge bends one way that will be convex for one side and concave for the other, it needs to bend both ways and split into 3 instead of 2.
  - A bifurcating split explains how to get through the entire material.
  - How to have the split turn around in a circle? What happens at that joint? Split into 3 again probobly.
  - Would need to deal with these fracture splits colliding.
  - Would need to detect when splits create a closed set of faces.
  - Cone fracture idea:
    - Cone:
      - Create a convex ring around impact point.
      - Create smaller ring set inside.
        - Unsure of how to pick these points to ensure convex slices.
      - Create middle point inside smaller ring and set further inside.
      - This makes a cake lump shape, cut into slices.
      - Send these pieces flying back towards where the impact came from.
    - Sides:
      - ...
  - Maybe just need trisplits.
    - Do enough of those and it should look good enough probably.
    - Trisplit has a centre line.
    - All faces the that the centre line intersects with will get split 3 ways.
    - Should be exactly two faces ideally.
      - Unles it intersects a vertex, then things are harder.
      - Might be able to ignore that and let floating point chaos make it a rarity.
    - All other faces are either split in two or not split.
      - See which pair of the trisplit directions each vertex lies within.
      - Project the vertex onto the plane perpendicular to the centre line.
      - Put find which pair of trisplit directions the projected vertex has a positive (x,y) representation in their skewed co-ordinate space.

# 2025-07-27
- Auto face detection for a 3D model with edges.
  - Find connected edges that lie on the same plane.
