# 2025-08-01
- Decided to do n way splits.
  - Like cutting cake slices.
  - Plane splits that all join at a line.
  - Considering constraint that the largest angle between two planes can't be more than 180 degrees.
    - Will need to figure out how to test that.
    - Maybe provide helper to add a mid plane in such cases.
- Whiteboarding.
  - https://photos.google.com/photo/AF1QipMlhPhH3ZuOBuZnw3SmxLxZPqmdrXEGGSlCdQ2d
    - How to sort points in a circle without using atan2().
    - Four categories:
      - 1: Pointing straight up.
      - 2: Pointing to the right.
      - 3: Pointing straight down.
      - 4: Pointing to the left.
    - Get numeric category of points a and b and just subtract.
    - If both are the same and in either category 2 or 4 then compare gradient slopes.
  - https://photos.google.com/photo/AF1QipOCbo4GrRrH2JrCUjyeXDxIIj7vQAQFYO-AqOfm
    - Slicing planes A, B, C.
    - Face with vertices 1, 2, 3, 4.
    - Iterate through the edges 1->2, 2->3, 3->4, 4->1.
    - Add vertices and intersections with slicing planes into respective buckets.
    - Each plane has two vertex buckets:
      - On: Vertices that lie on the plane.
      - In: Vertices that lie within the angle between the plane and the next one e.g. A->B.
    - The On verticies are collected over the course of the entire model slicing and are sorted by angle to form a new convex face shared by adjacent split models.
    - The In vertices form the face for the respective split model inside that slice segment.
- How to determine whether a point lies within the A->B segment?
  - Use SALT.
  - This would work best in 2D space.
  - All these vectors and vertices are 3D.
  - Should maybe add Vec2 to the ga repo and have some Vec3 methods that return Vec2s that represent position on a 3D plane.
    - Can probably just use arbitrary basis vectors.
    - (x, y, z) -> (z, x, -y) is a good way to generate a non-parallel vector to the normal that can be projected to be orthogonal.

# 2025-07-28
- Implementing model with edges.
- Going to define a map of directional edges to reduce the overpainting that building/ had with drawing each face's edge, all edges being drawn twice.
- Compute the faces from the edges as needed.
- Doesn't make good use of hex-lines' ability to draw continuous lines, would have null points inbetween each edge.
- Not as bad as redundant draws but not as optimal.
- How to fill in a cube's edges with as few breaks as possible?
- Hard to find fewer than 4, each vertex needs to be visited 3 times, makes it hard to visit them all cleanly.
- Unsure if this optimisation is worth it.
  - Defining each face allows for the faces to have their own size and colour.
- Going to stick with a face list instead of edge map.
- Considering how to make impact fractures rather than a slice.
  - This would split the model up into more than two pieces and be able to keep the resulting pieces convex.
  - Ideally has a degree of randomness in the structure of the fracture and multiple directions that turn rather than going on forever like the plane split.
  - This involves creating new vertices that are within the face rather than on its edges.
    - Testing for whether a point is inside a face would probably need the SALT method.
    - Separating axis line theorum.
    - This assumes every face is convex.
      - If the fractured pieces are convex then so are all its faces.
    - For each edge check that the point is not on the outer side of it.
      - Would need to inspect two connected non-parallel edges to know which way "out" is.
- How to structure the 3 dimensional form of the fracture?
  - Maybe an initial number of spikes followed by splitting trapezoids.
  - Maybe a jagged cone shape.
    - Inner ring, random number of vertices.
    - At each ring edge have a split coming back towards the impact to have small pieces.
    - Then splits going into the model for the large fractures that span the entire thing.
    - Maybe a single line going inwards before creating the ring.
      - Probably can't be a jagged line or it might create concave pieces.
  - In order to remain convex every fracture edge going in must split into two fracture edges.
    - If the edge bends one way that will be convex for one side and concave for the other, it needs to bend both ways and split into 3 instead of 2.
  - A bifurcating split explains how to get through the entire material.
  - How to have the split turn around in a circle? What happens at that joint? Split into 3 again probobly.
  - Would need to deal with these fracture splits colliding.
  - Would need to detect when splits create a closed set of faces.
  - Cone fracture idea:
    - Cone:
      - Create a convex ring around impact point.
      - Create smaller ring set inside.
        - Unsure of how to pick these points to ensure convex slices.
      - Create middle point inside smaller ring and set further inside.
      - This makes a cake lump shape, cut into slices.
      - Send these pieces flying back towards where the impact came from.
    - Sides:
      - ...
  - Maybe just need trisplits.
    - Do enough of those and it should look good enough probably.
    - Trisplit has a centre line.
    - All faces the that the centre line intersects with will get split 3 ways.
    - Should be exactly two faces ideally.
      - Unles it intersects a vertex, then things are harder.
      - Might be able to ignore that and let floating point chaos make it a rarity.
    - All other faces are either split in two or not split.
      - See which pair of the trisplit directions each vertex lies within.
      - Project the vertex onto the plane perpendicular to the centre line.
      - Put find which pair of trisplit directions the projected vertex has a positive (x,y) representation in their skewed co-ordinate space.

# 2025-07-27
- Auto face detection for a 3D model with edges.
  - Find connected edges that lie on the same plane.
